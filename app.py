from flask import Flask, request, render_template, send_file, send_from_directory, Response, url_for
import os
import cv2
import mediapipe as mp
import csv
import matplotlib
matplotlib.use('Agg')  # For servers without display
import matplotlib.pyplot as plt
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader

app = Flask(__name__)
UPLOAD_FOLDER = "uploads"
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

mp_pose = mp.solutions.pose
mp_drawing = mp.solutions.drawing_utils

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/upload", methods=["POST"])
def upload():
    if "video" not in request.files:
        return "No file uploaded"

    file = request.files["video"]
    if file.filename == "":
        return "No selected file"

    filepath = os.path.join(app.config["UPLOAD_FOLDER"], file.filename)
    file.save(filepath)

    cap = cv2.VideoCapture(filepath)
    if not cap.isOpened():
        return "Could not process video"

    frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    fps = cap.get(cv2.CAP_PROP_FPS)
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

    detected_frames = 0
    accuracy_over_time = []
    snapshot_saved = False
    snapshot_path = os.path.join(app.config["UPLOAD_FOLDER"], "snapshot.png")

    # Exercise counters (dummy logic for now)
    pushups = 0
    squats = 0
    jumping_jacks = 0

    with mp_pose.Pose(static_image_mode=False, min_detection_confidence=0.5) as pose:
        frame_idx = 0
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            frame_idx += 1

            rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            results = pose.process(rgb)

            if results.pose_landmarks:
                detected_frames += 1
                mp_drawing.draw_landmarks(frame, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)

                # Fake exercise detection
                if frame_idx % 100 == 0:
                    pushups += 1
                if frame_idx % 120 == 0:
                    squats += 1
                if frame_idx % 150 == 0:
                    jumping_jacks += 1

            if not snapshot_saved and frame_idx == frame_count // 2:
                cv2.imwrite(snapshot_path, frame)
                snapshot_saved = True

            accuracy_over_time.append(round((detected_frames / frame_idx) * 100, 2))

    cap.release()

    accuracy = round((detected_frames / frame_count) * 100, 2)

    # Accuracy chart
    chart_path = os.path.join(app.config["UPLOAD_FOLDER"], "accuracy_chart.png")
    plt.figure()
    plt.plot(range(1, len(accuracy_over_time) + 1), accuracy_over_time, color='blue', label="Accuracy")
    plt.xlabel("Frame")
    plt.ylabel("Accuracy (%)")
    plt.title("Detection Accuracy Over Time")
    plt.legend()
    plt.savefig(chart_path)
    plt.close()

    # Pie chart
    labels = ["Push-ups", "Squats", "Jumping Jacks"]
    values = [pushups, squats, jumping_jacks]
    pie_path = os.path.join(app.config["UPLOAD_FOLDER"], "exercise_pie.png")
    plt.figure()
    plt.pie(values, labels=labels, autopct="%1.1f%%", startangle=140)
    plt.title("Exercise Distribution")
    plt.savefig(pie_path)
    plt.close()

    global analysis_result
    analysis_result = {
        "frame_count": frame_count,
        "fps": round(fps, 2),
        "detected_frames": detected_frames,
        "accuracy": accuracy,
        "accuracy_over_time": accuracy_over_time,
        "snapshot_path": f"/uploads/{os.path.basename(snapshot_path)}",
        "chart_path": f"/uploads/{os.path.basename(chart_path)}",
        "pie_chart": f"/uploads/{os.path.basename(pie_path)}",
        "pushups": pushups,
        "squats": squats,
        "jumping_jacks": jumping_jacks,
    }

    return render_template("result.html", **analysis_result)

@app.route("/download_pdf")
def download_pdf():
    global analysis_result
    filepath = os.path.join(app.config["UPLOAD_FOLDER"], "analysis_report.pdf")
    c = canvas.Canvas(filepath, pagesize=letter)
    width, height = letter

    # Header
    c.setFont("Helvetica-Bold", 20)
    c.drawCentredString(width / 2, height - 80, "Workout Analysis Report")
    c.setFont("Helvetica", 12)
    c.drawCentredString(width / 2, height - 110, "Generated by AI Fitness Coach")
    c.line(50, height - 120, width - 50, height - 120)

    # Stats
    y = height - 160
    c.setFont("Helvetica", 14)
    c.drawString(80, y, f"Total Frames: {analysis_result['frame_count']}")
    y -= 30
    c.drawString(80, y, f"FPS: {analysis_result['fps']}")
    y -= 30
    c.drawString(80, y, f"Detected Frames: {analysis_result['detected_frames']}")
    y -= 30
    c.drawString(80, y, f"Accuracy: {analysis_result['accuracy']} %")
    y -= 30
    c.drawString(80, y, f"Push-ups: {analysis_result['pushups']}")
    y -= 30
    c.drawString(80, y, f"Squats: {analysis_result['squats']}")
    y -= 30
    c.drawString(80, y, f"Jumping Jacks: {analysis_result['jumping_jacks']}")

    # Row layout of images
    row_y = height - 450
    image_width = 160
    image_height = 160
    x_positions = [70, 230, 390]

    snapshot_full = os.path.join(app.config["UPLOAD_FOLDER"], os.path.basename(analysis_result["snapshot_path"]))
    if os.path.exists(snapshot_full):
        c.drawImage(ImageReader(snapshot_full), x_positions[0], row_y, width=image_width, height=image_height)

    chart_full = os.path.join(app.config["UPLOAD_FOLDER"], "accuracy_chart.png")
    if os.path.exists(chart_full):
        c.drawImage(ImageReader(chart_full), x_positions[1], row_y, width=image_width, height=image_height)

    pie_full = os.path.join(app.config["UPLOAD_FOLDER"], "exercise_pie.png")
    if os.path.exists(pie_full):
        c.drawImage(ImageReader(pie_full), x_positions[2], row_y, width=image_width, height=image_height)

    c.setFont("Helvetica-Oblique", 10)
    c.drawCentredString(width / 2, 50, "This report was auto-generated.")

    c.save()
    return send_file(filepath, as_attachment=True)

# Serve uploads
@app.route('/uploads/<path:filename>')
def uploads(filename):
    return send_from_directory(app.config["UPLOAD_FOLDER"], filename)

# -------- Camera Streaming --------
@app.route("/camera")
def camera_page():
    return render_template("camera.html")

@app.route("/start_camera")
def start_camera():
    cam_index = int(request.args.get("camera_index", 0))
    return render_template("camera.html", stream_url=url_for('camera_feed', cam_index=cam_index), cam_index=cam_index)

@app.route("/camera_feed")
def camera_feed():
    cam_index = int(request.args.get("cam_index", 0))
    return Response(generate_camera_feed(cam_index), mimetype="multipart/x-mixed-replace; boundary=frame")

def generate_camera_feed(cam_index=0):
    cap = cv2.VideoCapture(cam_index)
    with mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5) as pose:
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            results = pose.process(rgb)
            if results.pose_landmarks:
                mp_drawing.draw_landmarks(frame, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)

            _, buffer = cv2.imencode(".jpg", frame)
            frame = buffer.tobytes()
            yield (b"--frame\r\nContent-Type: image/jpeg\r\n\r\n" + frame + b"\r\n")
    cap.release()

if __name__ == "__main__":
    app.run(debug=True)
